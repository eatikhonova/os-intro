---
# Front matter
lang: ru-RU
title: "Отчет по лабораторной работе №12"
subtitle: "Дисциплина: Операционные системы"
author: "Тихонова Екатерина Андреевна"

# Formatting
toc-title: "Содержание"
toc: true # Table of contents
toc_depth: 2
lof: true # List of figures
lot: true # List of tables
fontsize: 12pt
linestretch: 1.5
papersize: a4paper
documentclass: scrreprt
polyglossia-lang: russian
polyglossia-otherlangs: english
mainfont: PT Serif
romanfont: PT Serif
sansfont: PT Sans
monofont: PT Mono
mainfontoptions: Ligatures=TeX
romanfontoptions: Ligatures=TeX
sansfontoptions: Ligatures=TeX,Scale=MatchLowercase
monofontoptions: Scale=MatchLowercase
indent: true
pdf-engine: lualatex
header-includes:
  - \linepenalty=10 # the penalty added to the badness of each line within a paragraph (no associated penalty node) Increasing the value makes tex try to have fewer lines in the paragraph.
  - \interlinepenalty=0 # value of the penalty (node) added after each line of a paragraph.
  - \hyphenpenalty=50 # the penalty for line breaking at an automatically inserted hyphen
  - \exhyphenpenalty=50 # the penalty for line breaking at an explicit hyphen
  - \binoppenalty=700 # the penalty for breaking a line at a binary operator
  - \relpenalty=500 # the penalty for breaking a line at a relation
  - \clubpenalty=150 # extra penalty for breaking after first line of a paragraph
  - \widowpenalty=150 # extra penalty for breaking before last line of a paragraph
  - \displaywidowpenalty=50 # extra penalty for breaking before last line before a display math
  - \brokenpenalty=100 # extra penalty for page breaking after a hyphenated line
  - \predisplaypenalty=10000 # penalty for breaking before a display
  - \postdisplaypenalty=0 # penalty for breaking after a display
  - \floatingpenalty = 20000 # penalty for splitting an insertion (can only be split footnote in standard LaTeX)
  - \raggedbottom # or \flushbottom
  - \usepackage{float} # keep figures where there are in the text
  - \floatplacement{figure}{H} # keep figures where there are in the text
---

# Цель работы

Изучить основы программирования в оболочке ОС UNIX. Научится писать более сложные командные файлы с использованием логических управляющих
конструкций и циклов.

# Выполнение лабораторной работы

Используя команды getopts grep, написала командный файл, который анализирует командную строку с ключами: -iinputfile—прочитать данные из указанного
файла; -o outputfile—вывести данные в указанный файл; -p шаблон —указать
шаблон для поиска; -C —различать большие и малые буквы; -n —выдавать номера строк, а затем ищет в указанном файле нужные строки, определяемые ключом
–p. Для данной задачи я создала файл prog1.sh и написала соответствующие
скрипты.

![Первая программа](image/1.png){ #fig:001 }
 
Далее я проверила работу написанного скрипта, используя различные
опции, предварительно добавив право на исполнение файла (команда
«chmod+xprog1.sh»)и создав 2 файла, которые необходимы для выполнения
программы: asd1.txt и asd2.txt
 
![Проверка работы1](image/2.png){ #fig:002 }

Написала на языке Си программу, которая вводит число и определяет, является
ли оно больше нуля, меньше нуля или равно нулю. Затем программа завершается с помощью функции exit(n), передавая информацию в о коде завершения в
оболочку. Командный файл должен вызывать эту программу и, проанализировав
с помощью команды $?, выдать сообщение о том, какое число было введено.Для
данной задачи я создала 2 файла: chislo.c и chislo.sh и написала соответствующие
скрипты. 

![Программа на си](image/3.png){ #fig:003 }

![Программа sh](image/4.png){  #fig:004 }

Далее я проверила работу написанных скриптов (./chislo.sh) 

![Проверка работы](image/5.png){  #fig:005  }

Написала командный файл, создающий указанное число файлов, пронумерованных последовательно от 1 до N. Число файлов, которые необходимо создать, передаётся в аргументы командной строки. Этот же командный файл должен
уметь удалять все созданные им файлы.Для данной задачи я создала файл: file.sh
и написала соответствующий скрипт.

![Программа 3](image/6.png){  #fig:006 }

Далее я проверила работу написанного скрипта (./files.sh), предварительно
добавив право на исполнение файла (команда «chmod+x files.sh»). Сначала я
создала три файла (команда «./files.sh –c abc#.txt 3»), удовлетворяющие условию
задачи, а потом удалила их (команда «./files.sh –r abc#.txt 3»

![Проверка работы](image/7.png){ #fig:007 }

Написала командный файл, который с помощью команды tarзапаковывает
в архив все файлы в указанной директории. Модифицировала его так, чтобы
запаковывались только те файлы, которые были изменены менее недели тому
назад. Для данной задачи я создала файл: pr4.sh и написала соответствующий
скрипт.

![Программа4](image/8.png){ #fig:008 }

Далее я проверила работу написанного скрипта, предварительно добавив право
на исполнение файла (команда «chmod +xp rog4.sh»)и создав отдельный lab11 с
несколькими файлами. 

![Последняя проверка](image/9.png){ #fig:009 }

Написала пример командного файла, обрабатывающего любое
произвольное число аргументов командной строки, в том числе
превышающее десять. Например, скрипт может последовательно 
распечатывать значения всех переданных аргументов. 

![Пишем пример](image/10.png){ #fig:010 }

Проверила работу написанного скрипта (команды «./prog2.sh 0 1 2 3 4»
и «./prog2.sh 0 1 2 3 4 5 6 7 8 9 10 11»), предварительно добавив для него
право на выполнение (команда «chmod +x *.sh»). Вводила аргументы,
количество которых меньше 10 и больше 10.
Скрипт работает корректно.

![Проверяем работу](image/11.png){ #fig:011 }

3. Создала файл, в котором буду писать третий скрипт, и открыла его в
редакторе emacs, используя клавиши «Ctrl-x» и «Ctrl-f» (команды «touch
progls.sh» и «emacs &») 

![Создала файл](image/12.png){ #fig:012 }

Написала командный файл − аналог команды ls (без использования
самой этой команды и команды dir). Он должен выдавать информацию 
о нужном каталоге и выводить информацию о возможностях доступа к
файлам этого каталога

![Пишем командный файл](image/13.png){ #fig:013 }

Далее проверила работу скрипта (команда «./progls.sh ~»),
предварительно добавив для него право на выполнение (команда
«chmod +x *.sh»).
Скрипт работает корректно.

![Проверяем работу](image/14.png){ #fig:014 }

4. Для четвертого скрипта также создала файл (команда «touch
format.sh») и открыла его в редакторе emacs, используя клавиши «Ctrlx» и «Ctrl-f» (команда «emacs &»)

![Создаем файл](image/15.png){ #fig:015 }

Написала командный файл, который получает в качестве аргумента
командной строки формат файла (.txt, .doc, .jpg, .pdf и т.д.) и вычисляет
количество таких файлов в указанной директории. Путь к директории
также передаётся в виде аргумента командной строки

![Пишем командный файл](image/16.png){ #fig:016 }

Проверила работу написанного скрипта (команда «./format.sh ~ pdf sh txt
doc»), предварительно добавив для него право на выполнение (команда
«chmod +x *.sh»), а также создав дополнительные файлы с разными
расширениями (команда «touch file.pdf file1.doc file2.doc»).
Скрипт работает корректно.

![Проверяем работу](image/17.png){ #fig:017 }

# Контрольные вопросы:

1). Команда getopts осуществляет синтаксический анализ командной строки,
выделяя флаги, ииспользуется для объявления переменных. Синтаксис команды
следующий: getopts option-string variable [arg…] Флаги − это опции командной
строки, обычно помеченные знаком минус; Например,для команды ls флагом
может являться -F. Строка опций option-string − эт осписок возможных букв и
чисел соответствующего флага. Если ожидается, что некоторый флаг будет сопровождаться некоторым аргументом, то за символом, обозначающим этот флаг,
должно следовать двоеточие. Соответствующей переменной присваивается буква
данной опции. Еслик оманда getopts может распознать аргумент, то она возвращает истину. Принято включать getopts в цикл while и анализировать введённые
данные с помощью оператора case. Функция getopts включает две специальные
переменные среды −OPTARG и OPTIND. Если ожидается доплнительное значение,то OPTARG устанавливается в значение этого аргумента. Функция getopts
также понимает переменные типа массив, следовательно, можно использовать
её в функции не только для синтаксического анализа аргументов функций, но
и для анализа введённых пользователем данных. 
2). Приперечислении имён
файлов текущего каталога можно использовать следующие символы: 1 −соответствует произвольной, в том числе и пустой строке; 2 ?−соответствует любому
одинарному символу; 3 [c1-c2] − соответствует любому символу, лексикографически
находящемуся между символами с1 и с2. Например, 1.1 echo − выведет имена всех
файлов текущего каталога, что представляет собой простейший аналог команды ls; 1.2. ls.c−выведет все файлы с последними двумя символами, совпадающими
15
с.c. 1.3. echoprog.?−выведет все файлы, состоящие из пяти или шести символов,
первыми пятью символами которых являются prog.. 1.4.[a-z]−соответствует произвольному имени файла в текущем каталоге, начинающемуся с любой строчной
буквы латинского алфавита. 
3). Часто бывает необходимо обеспечить проведение
каких-либо действий циклически и управление дальнейшими действиями в зависимости от результатов проверки некоторого условия. Для решения подобных
задач язык программирования bash предоставляет возможность использовать
такие управляющие конструкции, как for, case, if иwhile. С точки зрения командного процессора эти управляющие конструкции являются обычными командами
и могут использоваться как при создании командных файлов, так и при работе
в интерактивном режиме. Команды,реализующие подобные конструкции, по
сути, являются операторами языка программирования bash. Поэтому при описании языка программирования bash термин оператор будет использоваться
наравне с термином команда. Команды ОСUNIX возвращают код завершения,
значение которого может быть использовано для принятия решения о дальнейших действиях. Команда test, например, создана специально для использования в командных файлах. Единственная функция этой команды заключается
в выработке кода завершения. 
4). Два несложных способа позволяют вам прерывать циклы в оболочке bash. Команда break завершает выполнение цикла,
а команда continue завершает данную итерацию блока операторов. Команда
break полезна для завершения цикла while в ситуациях, когда условие перестаёт
быть правильным. Команда continue используется в ситуациях, когда больше нет
необходимости выполнять блок операторов, но вы можете захотеть продолжить
проверять данный блок на других условных выражениях. 
5)Следующие две команды ОСUNIX используются только совместно с управляющими конструкциями
языка программирования bash: это команда true,которая всегда возвращает код
завершения, равный нулю(т.е.истина),и команда false,которая всегда возвращает
код завершения,неравный нулю(т.е.ложь).Примеры бесконечных циклов:while
true do echo hello andy done until false do echo hello mike done
6)Строка iftest16
fman𝑠/i.𝑠, 𝑚𝑎𝑛s/𝑖.s и является ли этот файл обычным файлом.Если данный файл
является каталогом,то команда вернет нулевое значение(ложь). 
7)Выполнение
оператора цикла while сводится к тому,что сначала выполняется последовательность команд(операторов), которую задаёт список-команд в строке,содержащей
служебное слово while, а затем,если последняя выполненная команда из этой
последовательности команд возвращает нулевой код завершения(истина), выполняется последовательность команд(операторов), которую задаёт список-команд в
строке, содержащей служебное слово do,после чего осуществляется безусловный
переход на начало оператора цикла while.Выход из цикла будет осуществлён
тогда,когда последняя выполненная команда из последовательности команд
(операторов),которую задаёт список-команд в строке,содержащей служебное
слово while, возвратит ненулевой код завершения(ложь). При замене в операторе
цикла while служебного слова while на until условие,при выполнении которого осуществляется выход из цикла,меняется на противоположное. В остальном
оператор цикла while и оператор цикла until идентичны
# Выводы

В ходе выполнения данной лабораторной работы я изучилаосновы программирования в оболочке ОС UNIXи научилась писать более сложные командные файлы
с использованием логических управляющих конструкций и циклов.
